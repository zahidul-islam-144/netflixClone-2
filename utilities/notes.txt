/*

All the codes are kept as a backup in this textFile for further purposes(hints and tricks) to avoid complexity if needed.

*/



// import type { NextPage } from "next";
import Head from "next/head";
import Image from "next/image";
import { allURI } from "../assets/apiKeys";
import TopHeader from "../components/TopHeader";
import Layout from "../components/Layout";
import styles from "../styles/Home.module.css";
import { Movie, MoviePropsType, ObjType,  UriType } from "../utilities/types";
import Banner from "./banner";
import Movies from "./movies/movies";
import { useFetchMovies } from "../hooks/useFetchMovies";
import useStorage from "../hooks/useMovies";



const Home = ({
  netflixOriginals,
  topRated,
  trending,
  adeventure,
  fantasy,
  animation,
  drama,
  action,
  comedy,
  history,
  horror,
  thriller,
  scienceFiction,
  family,
  romance,
  documentry,
  movieObjects
}: MoviePropsType) => {
  
  useFetchMovies(movieObjects);
  const aaa = useStorage()
console.log("ðŸ’›aaa", aaa);
  return (
    <>
      <Head>
        <title>Netflix</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Banner netflixOriginals={netflixOriginals}/>
      {/* <Movies/> */}
    </>
  );
};

export default Home;

// server-side-rendering : SSR
export const getServerSideProps = async (context:any) => {
  const {req, res} = context;

  let movieObjects = {} as ObjType;
 
  const promiseResponse = await Promise.all(
    allURI.map(async (uri: UriType) => {
      const getMoviesData = await fetch(uri?.movieURL);
      const jsonConvertedData = await getMoviesData.json();
      movieObjects[uri?.movieType] = jsonConvertedData?.results;
    })
  );

  res.setHeader(
    'Cache-Control',
    'public, s-maxage=10, stale-while-revalidate=59'
    )

  return {
    props: {
      netflixOriginals: movieObjects?.netflixOriginals,
      topRated: movieObjects?.topRated,
      trending: movieObjects?.trending,
      adeventure: movieObjects?.adeventure,
      fantasy: movieObjects?.fantasy,
      animation: movieObjects?.animation,
      drama: movieObjects?.drama,
      action: movieObjects?.action,
      comedy: movieObjects?.comedy,
      history: movieObjects?.history,
      horror: movieObjects?.horror,
      thriller: movieObjects?.thriller,
      scienceFiction: movieObjects?.scienceFiction,
      family: movieObjects?.family,
      romance: movieObjects?.romance,
      documentry: movieObjects?.documentry,
      movieObjects: movieObjects
    },
  };
};

/*
  console.log("ðŸ’›ðŸ’›ðŸ’› ", `${process.env.NEXT_PUBLIC_BASE_URL}/discover/tv?api_key=${process.env.NEXT_PUBLIC_API_KEY}&with_networks=213`)

  await Promise.all([
    fetch(uri.netflixOriginal).then((res) => res.json()),
    fetch(uri.topRated).then((res) => res.json()),
    fetch(uri.trending).then((res) => res.json()),
    fetch(uri.adeventure).then((res) => res.json()),
    fetch(uri.fantasy).then((res) => res.json()),
    fetch(uri.animation).then((res) => res.json()),
    fetch(uri.drama).then((res) => res.json()),
    fetch(uri.action).then((res) => res.json()),
    fetch(uri.comedy).then((res) => res.json()),
    fetch(uri.history).then((res) => res.json()),
    fetch(uri.horror).then((res) => res.json()),
    fetch(uri.thriller).then((res) => res.json()),
    fetch(uri.scienceFiction).then((res) => res.json()),
    fetch(uri.family).then((res) => res.json()),
    fetch(uri.romance).then((res) => res.json()),
    fetch(uri.documentry).then((res) => res.json()),
  ]);
  return {
    props: {
      netflixOriginal: netflixOriginal.results,
      topRated: topRated.results,
      trending: trending.results,
      adeventure: adeventure.results,
      fantasy: fantasy.results,
      animation: animation.results,
      drama: drama.results,
      action: action.results,
      comedy: comedy.results,
      history: history.results,
      horror: horror.results,
      thriller: thriller.results,
      scienceFiction: scienceFiction.results,
      family: family.results,
      romance: romance.results,
      documentry: documentry.results,
    },
  };

*/


============>
login:alternative

import React, { Dispatch, SetStateAction, useState } from "react";
import Image from "next/image";
import Link from "next/link";
// import { Value } from "sass";

// interface HTMLProps<T> extends HTMLAttributes, ClassAttributes<T> {
// }
type inputTypes = {
  phn_email?: string | null;
  password?: string | null;
  // formInput: String | any,
  // setFormInput: Dispatch<SetStateAction<object|any>>
};

const Login = () => {
  const [formInput, setFormInput] = useState<inputTypes>({
    phn_email: '',
    password: '',
  });

  const handleInput = (e: React.FormEvent<HTMLInputElement>): void => {
    const { name, value } = e.target as HTMLInputElement;
    setFormInput((prevInput)=> ({ ...prevInput, [name]: value }))
    // setFormInput({...formInput, [name]: value });
  };
  console.log("ðŸ’›formInput", formInput);
  return (
    <div className="loginBanner_main">
      <div className="bannerBlock">
        <Image
          src="/../public/images/netflix-loginBanner.jpg"
          alt="loginBannerImage"
          layout="fill"
          objectFit="cover"
          quality={100}
          loading="lazy"
        />
      </div>

      <div className="authBlock">
        <h1>Sign In</h1>
        <form>
          <input
            type="text"
            placeholder="Email or Phone Number"
            name="phn_email"
            value={formInput.phn_email || ""}
            onChange={handleInput}
          />
          <input
            type="password"
            placeholder="Password"
            name="password"
            value={formInput.password || ""}
            onChange={handleInput}
          />
          <button>Sign In</button>
        </form>

        <div className="formBottomBlock">
          <div className="rememberMe">
            <input type="checkbox" id="remember" name="remember" value="Bike" />
            <label htmlFor="remember"> Remember me.</label>
          </div>

          <div className="forgotPassword">
            <Link href="#">Forgot password?</Link>
          </div>
        </div>

        <div className="signUpBlock">
          <h3>New to Netflix?</h3>
          <Link href="#">Sign up</Link>
        </div>
      </div>
    </div>
  );
};

export default Login;

========

const styles: { [key: string]: React.CSSProperties } = {
  checkbox: {
    margin: "10px 0",
    padding: "14px 25px",
    backgroundColor: "rgb(238 237 247)",
    width: "100%",
    display: "flex",
    justifyContent: "space-between",
  },
  button: {
    marginTop: 15,
    color: "#ffffff",
    width: "100%",
    cursor: "pointer",
    padding: "15px 30px",
    border: "none",
    fontWeight: "bold",
    backgroundColor: "red",
  },
}


/// row.tsx
// import { type } from "os";
import React, { useState, useRef } from "react";
import { IoIosArrowBack, IoIosArrowForward } from "react-icons/io";
import { MdArrowForwardIos, MdArrowBackIos } from "react-icons/md";
import { capitalizeFirstLetter } from "../utilities/utilities";
import { Movie } from "../utilities/types";
import SingleMovieCard from "./singleMovieCard";

type propsType = {
  movieCategory: any;
};

const Row = ({ movieCategory }: propsType) => {
  const [isMouseEnter, setIsMouseEnter] = useState<boolean>(false);
  const [isRightArrowClicked, setIsRightArrowClicked] =
    useState<boolean>(false);
  const [isMoved, setIsMoved] = useState<boolean>(false);
  const sliderRef = useRef<HTMLDivElement>(null);

  // handle slider functionalities:
  const hanldeSlider = (direction: string) => {
    setIsMoved(true);
    if (sliderRef.current) {
      const { scrollLeft, clientWidth } = sliderRef.current;
      const scrollTo =
        direction === "LEFT"
          ? scrollLeft - clientWidth
          : scrollLeft + clientWidth;
      sliderRef.current.scrollTo({ left: scrollTo, behavior: "smooth" });
    }
  };

  return (
    <div
      className="row_wrapper"
      onMouseEnter={() => setIsMouseEnter(true)}
      onTouchStart={() => setIsMouseEnter(true)}
      onMouseLeave={() => setIsMouseEnter(false)}
    >
      <h1 className="movieTitle">{capitalizeFirstLetter(movieCategory[0])}</h1>

      <div className="rowElementWrapper">
        {isMouseEnter && isRightArrowClicked && (
          <MdArrowBackIos
            className="rowSlider leftArrow"
            onClick={() => hanldeSlider("LEFT")}
          />
        )}
        <div className="rowBlock" ref={sliderRef}>
          {movieCategory[1].slice(0,15).map((singleMovieCard: Movie) => (
            <SingleMovieCard
              key={singleMovieCard?.id}
              singleMovieCard={singleMovieCard}
            />
          ))}
        </div>
        {isMouseEnter && (
          <MdArrowForwardIos
            className="rowSlider rightArrow"
            onClick={() => {
              setIsRightArrowClicked(true);
              hanldeSlider("RIGHT");
            }}
          />
        )}
      </div>
    </div>
  );
};

export default Row;


/// row.scss
@tailwind base;
@tailwind components;
@tailwind utilities;
@tailwind variants;

@layer components {
  .row_wrapper {
    @apply h-auto w-full ;

    .movieTitle {
      @apply mb-1 font-semibold text-[#e5e5e5] transition duration-200 hover:text-white cursor-pointer text-sm xs:text-base sm:text-lg md:text-lg lg:text-xl xl:text-2xl;
    }

    .rowElementWrapper {
      @apply h-auto w-full relative;

      .rowSlider {
        @apply absolute w-[3.5vw] h-full top-0 bottom-0 text-sm cursor-pointer bg-[#00000070] m-auto;

        &.leftArrow {
          @apply left-0 z-10;
        }

        &.rightArrow {
          @apply right-0;
        }
      }

      .rowBlock {
        @apply flex space-x-2 overflow-x-scroll scrollbar-hide ;
      }
    }
  }
}


//// singleMovieCard.tsx
import React, { useState } from "react";
import Image from "next/image";
import { Movie } from "../utilities/types";

type propsType = {
  singleMovieCard: Movie;
};

const SingleMovieCard = ({ singleMovieCard }: propsType) => {
  const [isMouseUp, setIsMouseUp] = useState<boolean>(false);
  const baseURL = process.env.NEXT_PUBLIC_IMAGE_BASE_URL;
  const imageSrc = `${baseURL}${
    singleMovieCard?.backdrop_path || singleMovieCard?.poster_path
  }`;

const handleMouseUp = () => {
  setTimeout(() => {
    setIsMouseUp(true);
    console.log('isMouseUp', isMouseUp);
  }, 10000);
}
  return (
    <div className="singleMovieCard">
      <div className={`cardImageBlock ${isMouseUp ? 'mouseUp':'cardImageBlock'}`} >
        <Image
          src={imageSrc}
          alt={`Image of ${
            singleMovieCard?.name || singleMovieCard?.original_name
          }`}
          quality={100}
          loading="lazy"
          layout="fill"
          className="cardImage"
        />
      </div>

      <div className="singleMovieCardContent_block">
          aaaaa
          bbbbb
          ccccc
      </div>
    </div>
  );
};

export default SingleMovieCard;


/// singleMovieCard.scss
@tailwind base;
@tailwind components;
@tailwind utilities;
@tailwind variants;

@layer components {
  .singleMovieCard {
    @apply h-auto w-auto transition-all inline-block cursor-pointer;

    .cardImageBlock {
      @apply max-h-32 h-16 xs:h-24 sm:h-28 md:h-44 lg:h-[135px] xl:h-60 min-h-fit w-[11vw] xs:w-[12vw] sm:w-[10vw] md:w-[13.5vw] lg:w-[280px] xl:w-[15vw] overflow-hidden relative ;

      .cardImage {
        @apply h-full w-full object-cover ;
        // hover:scale-[1.08] ease-in duration-500;
      }
      // &.mouseOver {
      //   @apply h-80 w-[18vw] transition-all ease-in-out duration-[30ms]
        
      // }

      &:hover{
        @apply lg:h-[350px] lg:w-[300px] lg:ease-in-out lg:duration-1000 lg:z-10 lg:absolute lg:shadow-md;

        .cardImage {
          @apply h-[135px]
        }
      }
    }

    .singleMovieCardContent_block{
      @apply h-auto w-full text-white
    }
  }
}
